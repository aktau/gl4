## Project 3: N-Body Simulation

Controls:

* Drag mouse: rotate camera
* Scroll wheel: zoom camera
* R: reset particles
* P: pause simulation
* O: change post-processing effect

## Introduction

This project implements a simulation of a large number of point masses acting under gravity. It uses the simple O(n2) algorithm that computes the force on each point mass due to all other point masses. However, the GPU can still simulate over 16,000 particles interacting at 60 fps.

## Implementation

This was implemented using OpenGL 4 with Verlet integration. Under Verlet integration, the next position of the particle is calculated using only the previous two positions and the acceleration: next = 2 * current - previous + acceleration. I stored this information for all 16,384 particles in three 128x128 textures (for the previous, current, and next positions).

The particles were rendered using point primitives with a size inversely proportional to the distance from the camera. Anti-aliasing was computed using the distance from the center of the point to gl_FragCoord.

The initial configuration used was two spherical wire cages generated from two long strings of particles. Particle positions were generated by rotating the vector (0, 0, 1) by an increasing angle about six different axes and then displacing the result either left or right. This generated more interesting motion than a uniformly random initial state because the intersections of wires quickly created local clumps of particles.

## Post Processing

I implemented two post-processing shaders: accumulation trails and hexagonal bokeh. The details of the hexagonal bokeh implementation can be found in the Siggraph 2011 talk [More Performance! Five Rendering Ideas from Battlefield 3 and Need for Speed: The Run](http://advances.realtimerendering.com/s2011/White,%20BarreBrisebois-%20Rendering%20in%20BF3%20%28Siggraph%202011%20Advances%20in%20Real-Time%20Rendering%20Course%29.pdf).
